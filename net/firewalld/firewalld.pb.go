// Code generated by protoc-gen-go. DO NOT EDIT.
// source: firewalld.proto

package firewalld

import (
	fmt "fmt"
	pb "github.com/bserdar/watermelon/server/pb"
	proto "github.com/golang/protobuf/proto"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type RichRuleAddress struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Invert               bool     `protobuf:"varint,2,opt,name=invert,proto3" json:"invert,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RichRuleAddress) Reset()         { *m = RichRuleAddress{} }
func (m *RichRuleAddress) String() string { return proto.CompactTextString(m) }
func (*RichRuleAddress) ProtoMessage()    {}
func (*RichRuleAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_45005c0220b690b7, []int{0}
}

func (m *RichRuleAddress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RichRuleAddress.Unmarshal(m, b)
}
func (m *RichRuleAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RichRuleAddress.Marshal(b, m, deterministic)
}
func (m *RichRuleAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RichRuleAddress.Merge(m, src)
}
func (m *RichRuleAddress) XXX_Size() int {
	return xxx_messageInfo_RichRuleAddress.Size(m)
}
func (m *RichRuleAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_RichRuleAddress.DiscardUnknown(m)
}

var xxx_messageInfo_RichRuleAddress proto.InternalMessageInfo

func (m *RichRuleAddress) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RichRuleAddress) GetInvert() bool {
	if m != nil {
		return m.Invert
	}
	return false
}

type RichRulePort struct {
	Port                 string   `protobuf:"bytes,1,opt,name=port,proto3" json:"port,omitempty"`
	Protocol             string   `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RichRulePort) Reset()         { *m = RichRulePort{} }
func (m *RichRulePort) String() string { return proto.CompactTextString(m) }
func (*RichRulePort) ProtoMessage()    {}
func (*RichRulePort) Descriptor() ([]byte, []int) {
	return fileDescriptor_45005c0220b690b7, []int{1}
}

func (m *RichRulePort) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RichRulePort.Unmarshal(m, b)
}
func (m *RichRulePort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RichRulePort.Marshal(b, m, deterministic)
}
func (m *RichRulePort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RichRulePort.Merge(m, src)
}
func (m *RichRulePort) XXX_Size() int {
	return xxx_messageInfo_RichRulePort.Size(m)
}
func (m *RichRulePort) XXX_DiscardUnknown() {
	xxx_messageInfo_RichRulePort.DiscardUnknown(m)
}

var xxx_messageInfo_RichRulePort proto.InternalMessageInfo

func (m *RichRulePort) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *RichRulePort) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

type RichRule struct {
	Family               string           `protobuf:"bytes,1,opt,name=family,proto3" json:"family,omitempty"`
	Source               *RichRuleAddress `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Dest                 *RichRuleAddress `protobuf:"bytes,3,opt,name=dest,proto3" json:"dest,omitempty"`
	Port                 *RichRulePort    `protobuf:"bytes,4,opt,name=port,proto3" json:"port,omitempty"`
	SourcePort           *RichRulePort    `protobuf:"bytes,5,opt,name=sourcePort,proto3" json:"sourcePort,omitempty"`
	ForwardPort          *RichRulePort    `protobuf:"bytes,6,opt,name=forwardPort,proto3" json:"forwardPort,omitempty"`
	Protocol             string           `protobuf:"bytes,7,opt,name=protocol,proto3" json:"protocol,omitempty"`
	ServiceName          string           `protobuf:"bytes,8,opt,name=serviceName,proto3" json:"serviceName,omitempty"`
	Action               string           `protobuf:"bytes,9,opt,name=action,proto3" json:"action,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RichRule) Reset()         { *m = RichRule{} }
func (m *RichRule) String() string { return proto.CompactTextString(m) }
func (*RichRule) ProtoMessage()    {}
func (*RichRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_45005c0220b690b7, []int{2}
}

func (m *RichRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RichRule.Unmarshal(m, b)
}
func (m *RichRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RichRule.Marshal(b, m, deterministic)
}
func (m *RichRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RichRule.Merge(m, src)
}
func (m *RichRule) XXX_Size() int {
	return xxx_messageInfo_RichRule.Size(m)
}
func (m *RichRule) XXX_DiscardUnknown() {
	xxx_messageInfo_RichRule.DiscardUnknown(m)
}

var xxx_messageInfo_RichRule proto.InternalMessageInfo

func (m *RichRule) GetFamily() string {
	if m != nil {
		return m.Family
	}
	return ""
}

func (m *RichRule) GetSource() *RichRuleAddress {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *RichRule) GetDest() *RichRuleAddress {
	if m != nil {
		return m.Dest
	}
	return nil
}

func (m *RichRule) GetPort() *RichRulePort {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *RichRule) GetSourcePort() *RichRulePort {
	if m != nil {
		return m.SourcePort
	}
	return nil
}

func (m *RichRule) GetForwardPort() *RichRulePort {
	if m != nil {
		return m.ForwardPort
	}
	return nil
}

func (m *RichRule) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *RichRule) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *RichRule) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

type AddRuleRequest struct {
	HostId    string `protobuf:"bytes,2,opt,name=hostId,proto3" json:"hostId,omitempty"`
	Zone      string `protobuf:"bytes,3,opt,name=zone,proto3" json:"zone,omitempty"`
	Permanent bool   `protobuf:"varint,4,opt,name=permanent,proto3" json:"permanent,omitempty"`
	// Types that are valid to be assigned to Rule:
	//	*AddRuleRequest_Rich
	Rule                 isAddRuleRequest_Rule `protobuf_oneof:"rule"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *AddRuleRequest) Reset()         { *m = AddRuleRequest{} }
func (m *AddRuleRequest) String() string { return proto.CompactTextString(m) }
func (*AddRuleRequest) ProtoMessage()    {}
func (*AddRuleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_45005c0220b690b7, []int{3}
}

func (m *AddRuleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddRuleRequest.Unmarshal(m, b)
}
func (m *AddRuleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddRuleRequest.Marshal(b, m, deterministic)
}
func (m *AddRuleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddRuleRequest.Merge(m, src)
}
func (m *AddRuleRequest) XXX_Size() int {
	return xxx_messageInfo_AddRuleRequest.Size(m)
}
func (m *AddRuleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddRuleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddRuleRequest proto.InternalMessageInfo

func (m *AddRuleRequest) GetHostId() string {
	if m != nil {
		return m.HostId
	}
	return ""
}

func (m *AddRuleRequest) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *AddRuleRequest) GetPermanent() bool {
	if m != nil {
		return m.Permanent
	}
	return false
}

type isAddRuleRequest_Rule interface {
	isAddRuleRequest_Rule()
}

type AddRuleRequest_Rich struct {
	Rich *RichRule `protobuf:"bytes,5,opt,name=rich,proto3,oneof"`
}

func (*AddRuleRequest_Rich) isAddRuleRequest_Rule() {}

func (m *AddRuleRequest) GetRule() isAddRuleRequest_Rule {
	if m != nil {
		return m.Rule
	}
	return nil
}

func (m *AddRuleRequest) GetRich() *RichRule {
	if x, ok := m.GetRule().(*AddRuleRequest_Rich); ok {
		return x.Rich
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AddRuleRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AddRuleRequest_OneofMarshaler, _AddRuleRequest_OneofUnmarshaler, _AddRuleRequest_OneofSizer, []interface{}{
		(*AddRuleRequest_Rich)(nil),
	}
}

func _AddRuleRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AddRuleRequest)
	// rule
	switch x := m.Rule.(type) {
	case *AddRuleRequest_Rich:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rich); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AddRuleRequest.Rule has unexpected type %T", x)
	}
	return nil
}

func _AddRuleRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AddRuleRequest)
	switch tag {
	case 5: // rule.rich
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RichRule)
		err := b.DecodeMessage(msg)
		m.Rule = &AddRuleRequest_Rich{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AddRuleRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AddRuleRequest)
	// rule
	switch x := m.Rule.(type) {
	case *AddRuleRequest_Rich:
		s := proto.Size(x.Rich)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ReloadRequest struct {
	HostId               string   `protobuf:"bytes,2,opt,name=hostId,proto3" json:"hostId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReloadRequest) Reset()         { *m = ReloadRequest{} }
func (m *ReloadRequest) String() string { return proto.CompactTextString(m) }
func (*ReloadRequest) ProtoMessage()    {}
func (*ReloadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_45005c0220b690b7, []int{4}
}

func (m *ReloadRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReloadRequest.Unmarshal(m, b)
}
func (m *ReloadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReloadRequest.Marshal(b, m, deterministic)
}
func (m *ReloadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReloadRequest.Merge(m, src)
}
func (m *ReloadRequest) XXX_Size() int {
	return xxx_messageInfo_ReloadRequest.Size(m)
}
func (m *ReloadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReloadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReloadRequest proto.InternalMessageInfo

func (m *ReloadRequest) GetHostId() string {
	if m != nil {
		return m.HostId
	}
	return ""
}

func init() {
	proto.RegisterType((*RichRuleAddress)(nil), "firewalld.RichRuleAddress")
	proto.RegisterType((*RichRulePort)(nil), "firewalld.RichRulePort")
	proto.RegisterType((*RichRule)(nil), "firewalld.RichRule")
	proto.RegisterType((*AddRuleRequest)(nil), "firewalld.AddRuleRequest")
	proto.RegisterType((*ReloadRequest)(nil), "firewalld.ReloadRequest")
}

func init() { proto.RegisterFile("firewalld.proto", fileDescriptor_45005c0220b690b7) }

var fileDescriptor_45005c0220b690b7 = []byte{
	// 452 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x53, 0x41, 0x8b, 0xd3, 0x40,
	0x18, 0xb5, 0x6b, 0x4c, 0x93, 0xaf, 0xd5, 0x85, 0x11, 0xd6, 0x58, 0x3c, 0x94, 0x5c, 0x5c, 0x11,
	0x53, 0xa9, 0x07, 0x11, 0x64, 0x61, 0x57, 0x10, 0xbd, 0x88, 0xcc, 0xd1, 0xdb, 0x74, 0xe6, 0xab,
	0x1d, 0x98, 0x64, 0xb2, 0x33, 0x93, 0x96, 0xf5, 0x3f, 0xf8, 0x93, 0x05, 0xc9, 0x64, 0xda, 0x4d,
	0x96, 0x65, 0x7b, 0x9b, 0xf7, 0xe5, 0xbd, 0xef, 0xcd, 0x7b, 0x43, 0xe0, 0x74, 0x2d, 0x0d, 0xee,
	0x98, 0x52, 0xa2, 0xa8, 0x8d, 0x76, 0x9a, 0xa4, 0x87, 0xc1, 0x6c, 0x5a, 0x6a, 0xd1, 0x28, 0xec,
	0x3e, 0xe4, 0x5f, 0xe0, 0x94, 0x4a, 0xbe, 0xa1, 0x8d, 0xc2, 0x4b, 0x21, 0x0c, 0x5a, 0x4b, 0x32,
	0x18, 0xb3, 0xee, 0x98, 0x8d, 0xe6, 0xa3, 0xf3, 0x94, 0xee, 0x21, 0x39, 0x83, 0x58, 0x56, 0x5b,
	0x34, 0x2e, 0x3b, 0x99, 0x8f, 0xce, 0x13, 0x1a, 0x50, 0x7e, 0x01, 0xd3, 0xfd, 0x92, 0x9f, 0xda,
	0x38, 0x42, 0x20, 0xaa, 0xb5, 0x71, 0x41, 0xee, 0xcf, 0x64, 0x06, 0x89, 0x77, 0xe4, 0x5a, 0x79,
	0x75, 0x4a, 0x0f, 0x38, 0xff, 0x77, 0x02, 0xc9, 0x7e, 0x41, 0x6b, 0xb2, 0x66, 0xa5, 0x54, 0x37,
	0x41, 0x1e, 0x10, 0x59, 0x42, 0x6c, 0x75, 0x63, 0x38, 0x7a, 0xf9, 0x64, 0x39, 0x2b, 0x6e, 0x43,
	0xde, 0x89, 0x40, 0x03, 0x93, 0x14, 0x10, 0x09, 0xb4, 0x2e, 0x7b, 0x7c, 0x54, 0xe1, 0x79, 0xe4,
	0x6d, 0xb8, 0x78, 0xe4, 0xf9, 0x2f, 0xee, 0xe1, 0xb7, 0xf9, 0x42, 0xa2, 0x8f, 0x00, 0x9d, 0x4d,
	0x3b, 0xcb, 0x9e, 0x3c, 0x2c, 0xe9, 0x51, 0xc9, 0x27, 0x98, 0xac, 0xb5, 0xd9, 0x31, 0x23, 0xbc,
	0x32, 0x7e, 0x58, 0xd9, 0xe7, 0x0e, 0x5a, 0x1c, 0x0f, 0x5b, 0x24, 0x73, 0x98, 0x58, 0x34, 0x5b,
	0xc9, 0xf1, 0x07, 0x2b, 0x31, 0x4b, 0xfc, 0xe7, 0xfe, 0xa8, 0xad, 0x96, 0x71, 0x27, 0x75, 0x95,
	0xa5, 0x5d, 0xb5, 0x1d, 0xca, 0xff, 0x8e, 0xe0, 0xd9, 0xa5, 0x10, 0xad, 0x25, 0xc5, 0xeb, 0xa6,
	0x6d, 0xe2, 0x0c, 0xe2, 0x8d, 0xb6, 0xee, 0xbb, 0x08, 0x8f, 0x15, 0x50, 0xfb, 0xb4, 0x7f, 0x74,
	0x85, 0xbe, 0xd1, 0x94, 0xfa, 0x33, 0x79, 0x05, 0x69, 0x8d, 0xa6, 0x64, 0x15, 0x56, 0x5d, 0x75,
	0x09, 0xbd, 0x1d, 0x90, 0x37, 0x10, 0x19, 0xc9, 0x37, 0xa1, 0xa0, 0xe7, 0xf7, 0xc4, 0xfc, 0xf6,
	0x88, 0x7a, 0xca, 0x55, 0x0c, 0x91, 0x69, 0x14, 0xe6, 0xaf, 0xe1, 0x29, 0x45, 0xa5, 0x99, 0x38,
	0x72, 0x9b, 0xe5, 0x35, 0xa4, 0x5f, 0xf7, 0xeb, 0xc8, 0x12, 0xc6, 0x21, 0x04, 0x79, 0xd9, 0x73,
	0x19, 0x06, 0x9b, 0x4d, 0x8b, 0x7a, 0x55, 0x50, 0xb4, 0xb5, 0xae, 0x2c, 0x92, 0xf7, 0x10, 0x77,
	0x4e, 0x24, 0xeb, 0x5f, 0xac, 0x6f, 0x3e, 0x54, 0x5c, 0x5d, 0xfc, 0xfa, 0xfc, 0x5b, 0xba, 0x4d,
	0xb3, 0x2a, 0xb8, 0x2e, 0x17, 0x5c, 0xe9, 0x46, 0xd4, 0x46, 0x6e, 0x19, 0xbf, 0x51, 0x6c, 0x65,
	0x17, 0x3b, 0xe6, 0xd0, 0x94, 0xa8, 0x74, 0xf5, 0xae, 0xfb, 0xcf, 0xec, 0xa2, 0x42, 0xb7, 0x38,
	0xec, 0x5e, 0xc5, 0xfe, 0xbd, 0x3e, 0xfc, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x62, 0xa3, 0x7c, 0xf0,
	0xa3, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FirewalldClient is the client API for Firewalld service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FirewalldClient interface {
	AddRule(ctx context.Context, in *AddRuleRequest, opts ...grpc.CallOption) (*pb.Response, error)
	Reload(ctx context.Context, in *ReloadRequest, opts ...grpc.CallOption) (*pb.Response, error)
}

type firewalldClient struct {
	cc *grpc.ClientConn
}

func NewFirewalldClient(cc *grpc.ClientConn) FirewalldClient {
	return &firewalldClient{cc}
}

func (c *firewalldClient) AddRule(ctx context.Context, in *AddRuleRequest, opts ...grpc.CallOption) (*pb.Response, error) {
	out := new(pb.Response)
	err := c.cc.Invoke(ctx, "/firewalld.Firewalld/AddRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewalldClient) Reload(ctx context.Context, in *ReloadRequest, opts ...grpc.CallOption) (*pb.Response, error) {
	out := new(pb.Response)
	err := c.cc.Invoke(ctx, "/firewalld.Firewalld/Reload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FirewalldServer is the server API for Firewalld service.
type FirewalldServer interface {
	AddRule(context.Context, *AddRuleRequest) (*pb.Response, error)
	Reload(context.Context, *ReloadRequest) (*pb.Response, error)
}

func RegisterFirewalldServer(s *grpc.Server, srv FirewalldServer) {
	s.RegisterService(&_Firewalld_serviceDesc, srv)
}

func _Firewalld_AddRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewalldServer).AddRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/firewalld.Firewalld/AddRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewalldServer).AddRule(ctx, req.(*AddRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Firewalld_Reload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewalldServer).Reload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/firewalld.Firewalld/Reload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewalldServer).Reload(ctx, req.(*ReloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Firewalld_serviceDesc = grpc.ServiceDesc{
	ServiceName: "firewalld.Firewalld",
	HandlerType: (*FirewalldServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddRule",
			Handler:    _Firewalld_AddRule_Handler,
		},
		{
			MethodName: "Reload",
			Handler:    _Firewalld_Reload_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "firewalld.proto",
}
